"use strict";(self.webpackChunkblog_vertexcover=self.webpackChunkblog_vertexcover||[]).push([[8392],{614:(e,t,n)=>{n.d(t,{A:()=>r});n(6540);var a=n(4848);function r({children:e}){return(0,a.jsxs)("div",{className:"bg-gray-50 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-4 my-5 border-l-4 border-l-blue-500 dark:border-l-blue-400",children:[(0,a.jsx)("strong",{className:"text-blue-600 dark:text-blue-400 text-sm uppercase tracking-wide font-semibold",children:"TL;DR:"}),(0,a.jsx)("div",{className:"mt-2 text-gray-800 dark:text-gray-200",children:e})]})}},3345:e=>{e.exports=JSON.parse('{"permalink":"/why-nodejs-python-avoid-linux-aio","source":"@site/blog/2025-11-08-nodejs-python-linux-async-io.mdx","title":"Why Node.js and Python Don\'t Use Linux\'s Native Async I/O API","description":"Linux provides a native Asynchronous I/O (AIO) API that should theoretically allow true background file operations. Yet popular frameworks like Node.js and Python\'s asyncio avoid it entirely, relying instead on thread pools with blocking I/O. Why? The answer reveals important lessons about API design, cross-platform compatibility, and the gap between theoretical elegance and practical engineering. The future may lie in io_uring, a modern interface that addresses many of AIO\'s shortcomings.","date":"2025-11-08T00:00:00.000Z","tags":[{"inline":false,"label":"Infrastructure","permalink":"/tags/infra","description":"Infrastructure"}],"readingTime":10.31,"hasTruncateMarker":true,"authors":[{"name":"Ritesh Kadmawala","title":"Founder, Vertexcover Labs - AI-native engineering studio","url":"https://www.vertexcover.io","page":{"permalink":"/authors/ritesh"},"socials":{"linkedin":"https://www.linkedin.com/in/riteshkadmawala/","github":"https://github.com/kgritesh"},"imageURL":"https://github.com/kgritesh.png","key":"ritesh"}],"frontMatter":{"slug":"why-nodejs-python-avoid-linux-aio","title":"Why Node.js and Python Don\'t Use Linux\'s Native Async I/O API","date":"2025-11-08T00:00:00.000Z","authors":["ritesh"],"tags":["infra"],"draft":false},"unlisted":false,"nextItem":{"title":"Building a LinkedIn Scraper (and Turning It Into an MCP Integration)","permalink":"/linkedin-scraper-mcp-integration"}}')},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var a=n(6540);const r={},o=a.createContext(r);function i(e){const t=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(o.Provider,{value:t},e.children)}},9983:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var a=n(3345),r=n(4848),o=n(8453),i=n(614);const s={slug:"why-nodejs-python-avoid-linux-aio",title:"Why Node.js and Python Don't Use Linux's Native Async I/O API",date:new Date("2025-11-08T00:00:00.000Z"),authors:["ritesh"],tags:["infra"],draft:!1},l=void 0,d={authorsImageUrls:[void 0]},c=[];function u(e){const t={p:"p",...(0,o.R)(),...e.components};return(0,r.jsx)(i.A,{children:(0,r.jsx)(t.p,{children:"Linux provides a native Asynchronous I/O (AIO) API that should theoretically allow true background file operations. Yet popular frameworks like Node.js and Python's asyncio avoid it entirely, relying instead on thread pools with blocking I/O. Why? The answer reveals important lessons about API design, cross-platform compatibility, and the gap between theoretical elegance and practical engineering. The future may lie in io_uring, a modern interface that addresses many of AIO's shortcomings."})})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);