"use strict";(self.webpackChunkblog_vertexcover=self.webpackChunkblog_vertexcover||[]).push([[4458],{1017:e=>{e.exports=JSON.parse('{"permalink":"/learnings/2025-10-ranjan-week2","source":"@site/learnings/2025-10-ranjan-week2.mdx","title":"Weekly learnings: Week2","description":"Developed a comprehensive benchmarking framework for comparing container image formats (regular vs eStargz) for large LLM workloads using containerd and stargz-snapshotter.","date":"2025-10-22T00:00:00.000Z","tags":[],"readingTime":13.88,"hasTruncateMarker":true,"authors":[{"name":"Ranjan Ojha","title":"Software Engineer","url":"https://github.com/hungerarray","page":{"permalink":"/learnings/authors/ranjan"},"socials":{"github":"https://github.com/hungerarray","linkedin":"https://www.linkedin.com/in/ojha-ranjan/"},"imageURL":"https://github.com/hungerarray.png","key":"ranjan"}],"frontMatter":{"title":"Weekly learnings: Week2","date":"2025-10-22T00:00:00.000Z","type":"weekly","authors":["ranjan"],"tags":[],"draft":false},"unlisted":false,"nextItem":{"title":"AI Video Cutter - Week 2 Learnings","permalink":"/learnings/2025-10-aman-week2"}}')},6170:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});var i=s(1017),r=s(4848),l=s(8453);const t={title:"Weekly learnings: Week2",date:new Date("2025-10-22T00:00:00.000Z"),type:"weekly",authors:["ranjan"],tags:[],draft:!1},a=void 0,c={authorsImageUrls:[void 0]},d=[{value:"Key Findings",id:"key-findings",level:3},{value:"Key Results",id:"key-results",level:2},{value:"Cold Start Performance (Small Working Set - 2GB Image)",id:"cold-start-performance-small-working-set---2gb-image",level:3},{value:"Total Workload Completion (Large Working Set - 8GB Image) \u26a0\ufe0f",id:"total-workload-completion-large-working-set---8gb-image-\ufe0f",level:3},{value:"Key Insights",id:"key-insights",level:3},{value:"Technical Architecture",id:"technical-architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"How Lazy Pulling Works",id:"how-lazy-pulling-works",level:2},{value:"Phase 1: Metadata Fetch (~0.06s for 2GB image)",id:"phase-1-metadata-fetch-006s-for-2gb-image",level:3},{value:"Phase 2: Container Creation (~0.03s)",id:"phase-2-container-creation-003s",level:3},{value:"Phase 3: On-Demand Fetching (during container runtime)",id:"phase-3-on-demand-fetching-during-container-runtime",level:3},{value:"Performance Implications",id:"performance-implications",level:3},{value:"Implementation Highlights",id:"implementation-highlights",level:2},{value:"RPullImage Operation",id:"rpullimage-operation",level:3},{value:"Critical Bugs Discovered &amp; Fixed",id:"critical-bugs-discovered--fixed",level:2},{value:"1. Content Blob Caching",id:"1-content-blob-caching",level:3},{value:"2. Metadata Corruption",id:"2-metadata-corruption",level:3},{value:"3. Plain HTTP Registry Support",id:"3-plain-http-registry-support",level:3},{value:"eStargz Format Verification",id:"estargz-format-verification",level:2},{value:"Key Characteristics",id:"key-characteristics",level:3},{value:"Creating eStargz Images",id:"creating-estargz-images",level:3},{value:"Verification",id:"verification",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Decision Framework: Lazy Pulling vs Eager Loading",id:"decision-framework-lazy-pulling-vs-eager-loading",level:3},{value:"When to Use Lazy Pulling \u2705",id:"when-to-use-lazy-pulling-",level:3},{value:"When NOT to Use Lazy Pulling \u274c",id:"when-not-to-use-lazy-pulling-",level:3},{value:"Performance Optimization Matrix",id:"performance-optimization-matrix",level:3},{value:"Architecture Insights",id:"architecture-insights",level:2},{value:"Containerd Design Principles",id:"containerd-design-principles",level:3},{value:"Version Compatibility",id:"version-compatibility",level:3},{value:"Debugging Techniques",id:"debugging-techniques",level:2},{value:"1. Check Content Store Annotations",id:"1-check-content-store-annotations",level:3},{value:"2. Verify Lazy Pulling is Active",id:"2-verify-lazy-pulling-is-active",level:3},{value:"3. Binary Verification",id:"3-binary-verification",level:3},{value:"4. Monitor On-Demand Fetches",id:"4-monitor-on-demand-fetches",level:3},{value:"Quick Reference Commands",id:"quick-reference-commands",level:2},{value:"Setup",id:"setup",level:3},{value:"Benchmarking",id:"benchmarking",level:3},{value:"Cleanup",id:"cleanup",level:3},{value:"External Resources",id:"external-resources",level:2},{value:"Official Documentation",id:"official-documentation",level:3},{value:"Related Tools &amp; Projects",id:"related-tools--projects",level:3},{value:"Research Papers &amp; Articles",id:"research-papers--articles",level:3},{value:"Community &amp; Support",id:"community--support",level:3},{value:"Tutorials &amp; Guides",id:"tutorials--guides",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Technical Insights",id:"technical-insights",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:3},{value:"Development Best Practices",id:"development-best-practices",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Findings",id:"key-findings-1",level:3},{value:"Decision Framework",id:"decision-framework",level:3},{value:"Production Recommendations",id:"production-recommendations",level:3},{value:"Technical Validation",id:"technical-validation",level:3}];function o(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Developed a comprehensive benchmarking framework for comparing container image formats (regular vs eStargz) for large LLM workloads using containerd and stargz-snapshotter."}),"\n","\n",(0,r.jsx)(n.h3,{id:"key-findings",children:"Key Findings"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Lazy pulling with eStargz provides dramatic startup improvements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"150x faster pull times"})," (9.2s \u2192 0.06s)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"13.9x faster cold starts"})," (9.4s \u2192 0.67s)"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Zero disk storage overhead"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"But reveals a critical trade-off for data-intensive workloads:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"1.5-2x slower total completion"})," when accessing >30% of image data"]}),"\n",(0,r.jsx)(n.li,{children:"Stress test (8GB sequential read): Overlayfs 45-54s vs Stargz 79-88s"}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Working set size determines which approach is faster"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bottom line:"})," Lazy pulling optimizes for startup latency (ideal for inference/serving), while eager loading optimizes for total completion time (better for training/batch processing)."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"key-results",children:"Key Results"}),"\n",(0,r.jsx)(n.h3,{id:"cold-start-performance-small-working-set---2gb-image",children:"Cold Start Performance (Small Working Set - 2GB Image)"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Metric"}),(0,r.jsx)(n.th,{children:"Regular Pull"}),(0,r.jsx)(n.th,{children:"Lazy Pull (eStargz)"}),(0,r.jsx)(n.th,{children:"Improvement"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Pull time"})}),(0,r.jsx)(n.td,{children:"9.178s"}),(0,r.jsx)(n.td,{children:"0.061s"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"150x faster"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Container start + ready"})}),(0,r.jsx)(n.td,{children:"199ms"}),(0,r.jsx)(n.td,{children:"587ms"}),(0,r.jsx)(n.td,{children:"Slower (on-demand fetch)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Total cold start"})}),(0,r.jsx)(n.td,{children:"9.401s"}),(0,r.jsx)(n.td,{children:"0.675s"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"13.9x faster"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Data downloaded at pull"})}),(0,r.jsx)(n.td,{children:"2.0 GB"}),(0,r.jsx)(n.td,{children:"~9 KB"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"99.9% reduction"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Disk usage after pull"})}),(0,r.jsx)(n.td,{children:"2.0 GB cached"}),(0,r.jsx)(n.td,{children:"0 bytes"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"100% savings"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scenario"}),": Application with small working set (~1-5% of image accessed)"]}),"\n",(0,r.jsx)(n.h3,{id:"total-workload-completion-large-working-set---8gb-image-\ufe0f",children:"Total Workload Completion (Large Working Set - 8GB Image) \u26a0\ufe0f"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CRITICAL TRADE-OFF"}),": When workloads access significant portions of the image, lazy pulling is ",(0,r.jsx)(n.strong,{children:"SLOWER"})," for total completion time."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Stress Test Results"})," (sequential read of 8GB data):"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Mode"}),(0,r.jsx)(n.th,{children:"Registry"}),(0,r.jsx)(n.th,{children:"File Pattern"}),(0,r.jsx)(n.th,{children:"Total Time"}),(0,r.jsx)(n.th,{children:"vs Overlayfs"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Overlayfs"})}),(0,r.jsx)(n.td,{children:"localhost"}),(0,r.jsx)(n.td,{children:"many-small"}),(0,r.jsx)(n.td,{children:"52s"}),(0,r.jsx)(n.td,{children:"baseline"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Overlayfs"})}),(0,r.jsx)(n.td,{children:"localhost"}),(0,r.jsx)(n.td,{children:"few-large"}),(0,r.jsx)(n.td,{children:"54s"}),(0,r.jsx)(n.td,{children:"baseline"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Overlayfs"})}),(0,r.jsx)(n.td,{children:"172.17.0.2"}),(0,r.jsx)(n.td,{children:"many-small"}),(0,r.jsx)(n.td,{children:"45s"}),(0,r.jsx)(n.td,{children:"baseline"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Overlayfs"})}),(0,r.jsx)(n.td,{children:"172.17.0.2"}),(0,r.jsx)(n.td,{children:"few-large"}),(0,r.jsx)(n.td,{children:"45s"}),(0,r.jsx)(n.td,{children:"baseline"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Stargz"})}),(0,r.jsx)(n.td,{children:"localhost"}),(0,r.jsx)(n.td,{children:"many-small"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"88s"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"1.7x slower"})," \u274c"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Stargz"})}),(0,r.jsx)(n.td,{children:"localhost"}),(0,r.jsx)(n.td,{children:"few-large"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"79s"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"1.5x slower"})," \u274c"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Stargz"})}),(0,r.jsx)(n.td,{children:"172.17.0.2"}),(0,r.jsx)(n.td,{children:"many-small"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"82s"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"1.8x slower"})," \u274c"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Stargz"})}),(0,r.jsx)(n.td,{children:"172.17.0.2"}),(0,r.jsx)(n.td,{children:"few-large"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"83s"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"1.8x slower"})," \u274c"]})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why Lazy Pulling is Slower for Data-Intensive Workloads:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Overlayfs (eager loading):\n  Bulk download: 45-53s (parallel, full bandwidth)\n  Workload execution: Fast (all data local on SSD)\n  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  Total: 45-54s\n\nStargz (lazy loading):\n  Metadata pull: &lt;1s\n  Workload execution: 78-87s (many serialized HTTP range requests)\n  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  Total: 79-88s (1.5-2x SLOWER!)\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Performance Breakdown:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pull phase"}),": Stargz wins (150x faster) \u2705"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execution phase"}),": Overlayfs wins (on-demand HTTP requests slower than local disk) \u2705"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Total time"}),": Depends on working set size and access pattern"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-insights",children:"Key Insights"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Cold start time \u2260 Total completion time"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Lazy pulling optimizes startup latency"}),"\n",(0,r.jsx)(n.li,{children:"BUT penalizes total workload completion when data access is substantial"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Working set size is critical"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Small working set (<10%): Lazy pulling wins dramatically (13.9x faster)"}),"\n",(0,r.jsx)(n.li,{children:"Large working set (>30%): Eager loading wins (1.5-2x faster)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"File pattern sensitivity"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Many small files: Worse for lazy pulling (88s vs 79s)"}),"\n",(0,r.jsx)(n.li,{children:"Each file = separate HTTP request = more latency overhead"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Network vs disk I/O trade-off"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Bulk parallel download: ~45-53s for 8GB"}),"\n",(0,r.jsx)(n.li,{children:"Serialized on-demand fetches: ~78-87s for same data"}),"\n",(0,r.jsx)(n.li,{children:"Local disk reads >> HTTP range requests for large data access"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"technical-architecture",children:"Technical Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"core-components",children:"Core Components"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Containerd Benchmark Framework"})," (",(0,r.jsx)(n.code,{children:"containerd-bench/"}),")"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pure Go API integration with containerd"}),"\n",(0,r.jsx)(n.li,{children:"Programmatic control over container lifecycle"}),"\n",(0,r.jsx)(n.li,{children:"JSON Lines logging for performance analysis"}),"\n",(0,r.jsx)(n.li,{children:"Operations: PullImage, RPullImage (lazy), CreateContainer, StartContainer, etc."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Lazy Pulling with eStargz"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses stargz-snapshotter plugin for on-demand layer fetching"}),"\n",(0,r.jsx)(n.li,{children:"HTTP range requests to fetch only needed chunks"}),"\n",(0,r.jsx)(n.li,{children:"FUSE filesystem for transparent lazy loading"}),"\n",(0,r.jsx)(n.li,{children:"Zero disk storage overhead"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Startup Benchmarking Tool"})," (",(0,r.jsx)(n.code,{children:"startup-bench/"}),")"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cold and warm start measurements"}),"\n",(0,r.jsx)(n.li,{children:"Container readiness detection (not just process start)"}),"\n",(0,r.jsxs)(n.li,{children:["Auto-detection of eStargz images by ",(0,r.jsx)(n.code,{children:":esgz"})," suffix"]}),"\n",(0,r.jsx)(n.li,{children:"Support for plain HTTP registries"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"how-lazy-pulling-works",children:"How Lazy Pulling Works"}),"\n",(0,r.jsx)(n.h3,{id:"phase-1-metadata-fetch-006s-for-2gb-image",children:"Phase 1: Metadata Fetch (~0.06s for 2GB image)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Download index (290B) + manifest (2.6KB) + config (6.3KB) = ~9KB\nRegister layers with stargz-snapshotter as "remote"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"phase-2-container-creation-003s",children:"Phase 2: Container Creation (~0.03s)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Stargz-snapshotter creates remote snapshot mounts\nFUSE filesystem presents layer contents virtually\nContainer starts WITHOUT waiting for layer downloads\n"})}),"\n",(0,r.jsx)(n.h3,{id:"phase-3-on-demand-fetching-during-container-runtime",children:"Phase 3: On-Demand Fetching (during container runtime)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Application reads /app/data/file.dat\n  \u2193\nFUSE intercepts read()\n  \u2193\nHTTP GET with Range: bytes=1024-2048 to registry\n  \u2193\nData returned (cached in memory, NOT disk)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Result"}),": For 2GB image with small working set (~20-30MB accessed), only those chunks are fetched."]}),"\n",(0,r.jsx)(n.h3,{id:"performance-implications",children:"Performance Implications"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Small Working Set (<10% of image):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Pull: &lt;1s (metadata only)\nRuntime: Fast (few on-demand fetches)\nTotal: 13.9x faster than eager loading \u2705\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Large Working Set (>30% of image):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Pull: &lt;1s (metadata only)\nRuntime: 78-87s (many serialized HTTP requests)\nTotal: 1.5-2x SLOWER than eager loading \u274c\n\nWhy slower:\n- Bulk parallel download: 45-53s for 8GB\n- On-demand serial fetches: 78-87s for same 8GB\n- Each file access = network round-trip\n- FUSE overhead + HTTP request overhead\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Trade-off:"})," Fast startup vs total completion time depends on working set size."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"implementation-highlights",children:"Implementation Highlights"}),"\n",(0,r.jsx)(n.h3,{id:"rpullimage-operation",children:"RPullImage Operation"}),"\n",(0,r.jsxs)(n.p,{children:["Used ",(0,r.jsx)(n.code,{children:"source.AppendDefaultLabelsHandlerWrapper()"})," from stargz-snapshotter:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'import (\n    "github.com/containerd/containerd/v2/client"\n    "github.com/containerd/stargz-snapshotter/fs/source"\n)\n\n// Create label handler - this enables lazy pulling!\nlabelHandler := source.AppendDefaultLabelsHandlerWrapper(imageRef, prefetchSize)\n\npullOpts := []client.RemoteOpt{\n    client.WithPullUnpack,\n    client.WithImageHandlerWrapper(labelHandler),  // Essential for lazy pulling\n    client.WithPullSnapshotter("stargz"),\n}\n\n_, err := containerdClient.Pull(ctx, imageRef, pullOpts...)\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Critical Insight"}),": Regular ",(0,r.jsx)(n.code,{children:"containerd.Pull()"})," downloads everything even with stargz snapshotter. The label handler wrapper is ",(0,r.jsx)(n.strong,{children:"essential"})," for true lazy pulling."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"critical-bugs-discovered--fixed",children:"Critical Bugs Discovered & Fixed"}),"\n",(0,r.jsx)(n.h3,{id:"1-content-blob-caching",children:"1. Content Blob Caching"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Cold start iterations reused cached content blobs (48s \u2192 0.17s on iteration 2)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Root Cause"}),": Content blobs are globally shared across namespaces. Image removal only cleared metadata."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Use ",(0,r.jsx)(n.code,{children:"images.SynchronousDelete()"})," to trigger immediate garbage collection:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"deleteOpts := []images.DeleteOpt{images.SynchronousDelete()}\nimageService.Delete(ctx, imageRef, deleteOpts...)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-metadata-corruption",children:"2. Metadata Corruption"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Mixing regular ",(0,r.jsx)(n.code,{children:"Pull()"})," and ",(0,r.jsx)(n.code,{children:"rpull"}),' caused "target snapshot already exists" errors.']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Root Cause"}),": Content blobs retained ",(0,r.jsx)(n.code,{children:"containerd.io/uncompressed"})," annotations from previous pulls."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Clean content store before lazy pulling:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"sudo ctr-remote content ls | grep workload | awk '{print $1}' | \\\n  xargs -I {} sudo ctr-remote content rm {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Prevention"}),": Never mix pull methods - always use RPullImage for eStargz images."]}),"\n",(0,r.jsx)(n.h3,{id:"3-plain-http-registry-support",children:"3. Plain HTTP Registry Support"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Custom Docker resolver breaks lazy pulling by forcing full downloads."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution for RPullImage"}),": Configure stargz-snapshotter daemon instead:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'# /etc/containerd-stargz-grpc/config.toml\n[[resolver.host."172.17.0.2:5000".mirrors]]\nhost = "172.17.0.2:5000"\ninsecure = true\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"estargz-format-verification",children:"eStargz Format Verification"}),"\n",(0,r.jsx)(n.h3,{id:"key-characteristics",children:"Key Characteristics"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Media Type"}),": ",(0,r.jsx)(n.code,{children:"application/vnd.oci.image.layer.v1.tar+gzip"})," (same as regular gzip!)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Distinguishing Features"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"STARGZ footer"})," in blob (verify with ",(0,r.jsx)(n.code,{children:"xxd"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TOC digest annotation"}),": ",(0,r.jsx)(n.code,{children:"containerd.io/snapshot/stargz/toc.digest"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Uncompressed size annotation"}),": ",(0,r.jsx)(n.code,{children:"io.containers.estargz.uncompressed-size"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"creating-estargz-images",children:"Creating eStargz Images"}),"\n",(0,r.jsx)(n.p,{children:"Use ctr-remote workflow (NOT docker buildx):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 1. Build regular image\ndocker buildx build -t localhost:5000/image:base --push .\n\n# 2. Pull to containerd\nsudo ctr-remote image pull localhost:5000/image:base\n\n# 3. Optimize to eStargz\nsudo ctr-remote image optimize --no-optimize --oci \\\n  localhost:5000/image:base localhost:5000/image:esgz\n\n# 4. Push eStargz image\nsudo ctr-remote images push --plain-http localhost:5000/image:esgz\n"})}),"\n",(0,r.jsx)(n.h3,{id:"verification",children:"Verification"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Check manifest annotations\ncurl -s http://localhost:5000/v2/image/manifests/esgz | \\\n  jq '.layers[].annotations'\n\n# Verify STARGZ footer in blob\nsudo tail -c 100 /var/lib/containerd/.../blobs/sha256/... | xxd | tail -3\n# Look for: \"STARGZ\" marker\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"decision-framework-lazy-pulling-vs-eager-loading",children:"Decision Framework: Lazy Pulling vs Eager Loading"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"The critical factor is WORKING SET SIZE:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Working Set < 10% of image:\n  \u2192 Use lazy pulling (13.9x faster startup)\n\nWorking Set > 30% of image:\n  \u2192 Use eager loading (1.5-2x faster total completion)\n\nWorking Set 10-30% of image:\n  \u2192 Depends on whether you optimize for startup or total time\n"})}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-lazy-pulling-",children:"When to Use Lazy Pulling \u2705"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Best for startup latency optimization:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Small working set"})," (<10% of image accessed)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Example: Web API loading libraries (100MB of 2GB image)"}),"\n",(0,r.jsx)(n.li,{children:"Result: 13.9x faster cold start"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Ephemeral workloads"})," - short-lived containers"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Containers that start, perform task, exit quickly"}),"\n",(0,r.jsx)(n.li,{children:"Don't benefit from caching anyway"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cold start critical"})," - startup time is the bottleneck"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Serverless functions"}),"\n",(0,r.jsx)(n.li,{children:"Auto-scaling scenarios"}),"\n",(0,r.jsx)(n.li,{children:"Development/testing iterations"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Limited disk space"})," - can't cache full images"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Edge devices"}),"\n",(0,r.jsx)(n.li,{children:"Multi-tenant nodes with many images"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"High bandwidth, low latency"})," to registry"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"On-demand fetches need fast network"}),"\n",(0,r.jsx)(n.li,{children:"Registry co-located with compute"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example Use Case:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"LLM Inference API:\n- Image: 4GB (model weights)\n- Working set: 300MB (actively loaded model portion)\n- Access pattern: Load once, serve many requests\n\nLazy pulling: 1-2s startup vs 18s eager\nResult: 9-18x faster! \u2705\n"})}),"\n",(0,r.jsx)(n.h3,{id:"when-not-to-use-lazy-pulling-",children:"When NOT to Use Lazy Pulling \u274c"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Eager loading is faster when:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Large working set"})," (>30% of image accessed)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Example: Batch processing reading 8GB of 8GB image"}),"\n",(0,r.jsx)(n.li,{children:"Result: Lazy pulling 1.5-2x SLOWER for total completion"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Data-intensive workloads"})," - process significant data"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Training jobs accessing entire dataset"}),"\n",(0,r.jsx)(n.li,{children:"ETL pipelines reading many files"}),"\n",(0,r.jsx)(n.li,{children:"Stress tests (like our benchmark)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Sequential file access"})," - many files read in order"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each file = separate HTTP request with lazy pulling"}),"\n",(0,r.jsx)(n.li,{children:"Bulk download is much faster (parallel, large chunks)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Small images"})," (<100MB) - overhead not worth it"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Metadata overhead dominates"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Slow/high-latency network"})," - on-demand fetches will be slow"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each file access waits for network round-trip"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Offline/air-gapped environments"})," - no registry access"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example Use Case:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"LLM Training/Fine-tuning:\n- Image: 8GB (dataset + checkpoints)\n- Working set: 7GB (accessing most data during training)\n- Access pattern: Read many files sequentially\n\nLazy pulling: 79-88s total time\nEager loading: 45-54s total time\nResult: Eager 1.5-2x faster! \u2705\n"})}),"\n",(0,r.jsx)(n.h3,{id:"performance-optimization-matrix",children:"Performance Optimization Matrix"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Metric to Optimize"}),(0,r.jsx)(n.th,{children:"Image Size"}),(0,r.jsx)(n.th,{children:"Working Set"}),(0,r.jsx)(n.th,{children:"Recommendation"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Cold start time"})}),(0,r.jsx)(n.td,{children:"Large (>1GB)"}),(0,r.jsx)(n.td,{children:"Small (<10%)"}),(0,r.jsx)(n.td,{children:"Lazy pulling \u2705"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Cold start time"})}),(0,r.jsx)(n.td,{children:"Large (>1GB)"}),(0,r.jsx)(n.td,{children:"Large (>30%)"}),(0,r.jsx)(n.td,{children:"Lazy pulling \u2705 (startup only)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Total completion time"})}),(0,r.jsx)(n.td,{children:"Large (>1GB)"}),(0,r.jsx)(n.td,{children:"Small (<10%)"}),(0,r.jsx)(n.td,{children:"Lazy pulling \u2705"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Total completion time"})}),(0,r.jsx)(n.td,{children:"Large (>1GB)"}),(0,r.jsx)(n.td,{children:"Large (>30%)"}),(0,r.jsx)(n.td,{children:"Eager loading \u2705"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Disk usage"})}),(0,r.jsx)(n.td,{children:"Any"}),(0,r.jsx)(n.td,{children:"Any"}),(0,r.jsx)(n.td,{children:"Lazy pulling \u2705"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Network bandwidth"})}),(0,r.jsx)(n.td,{children:"Large (>1GB)"}),(0,r.jsx)(n.td,{children:"Small (<10%)"}),(0,r.jsx)(n.td,{children:"Lazy pulling \u2705"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Network bandwidth"})}),(0,r.jsx)(n.td,{children:"Large (>1GB)"}),(0,r.jsx)(n.td,{children:"Large (>30%)"}),(0,r.jsx)(n.td,{children:"Eager loading \u2705"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"architecture-insights",children:"Architecture Insights"}),"\n",(0,r.jsx)(n.h3,{id:"containerd-design-principles",children:"Containerd Design Principles"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Content Store is Global"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Image metadata: namespaced \u2705"}),"\n",(0,r.jsx)(n.li,{children:"Container metadata: namespaced \u2705"}),"\n",(0,r.jsxs)(n.li,{children:["Content blobs: ",(0,r.jsx)(n.strong,{children:"GLOBAL"})," (shared across namespaces) \u274c"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Snapshotter Abstraction"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each snapshotter has unique requirements"}),"\n",(0,r.jsx)(n.li,{children:"Stargz needs special label handlers for lazy pulling"}),"\n",(0,r.jsx)(n.li,{children:"Not as simple as just switching a snapshotter flag"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Trade-offs"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Startup latency"}),": Lazy pulling dramatically faster (13.9x)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Total completion"}),": Depends on working set size","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Small working set (<10%): Lazy pulling wins (13.9x faster)"}),"\n",(0,r.jsx)(n.li,{children:"Large working set (>30%): Eager loading wins (1.5-2x faster)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Network vs Disk I/O"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Bulk parallel download: ~45-53s for 8GB"}),"\n",(0,r.jsx)(n.li,{children:"Serialized on-demand fetches: ~78-87s for same 8GB data"}),"\n",(0,r.jsx)(n.li,{children:"Local disk reads >> HTTP range requests for large data access"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zero storage overhead"})," vs traditional caching benefits"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Network-dependent performance"})," - requires good bandwidth/latency"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"version-compatibility",children:"Version Compatibility"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Critical"}),": Match library versions with system installations"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Check system version\ncontainerd --version  # v2.1.4\n\n# Use matching library version\ngo get github.com/containerd/containerd/v2@v2.1.4\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"debugging-techniques",children:"Debugging Techniques"}),"\n",(0,r.jsx)(n.h3,{id:"1-check-content-store-annotations",children:"1. Check Content Store Annotations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"sudo ctr-remote content ls | grep image\n# Look for: containerd.io/uncompressed annotations\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-verify-lazy-pulling-is-active",children:"2. Verify Lazy Pulling is Active"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Inside container, check for stargz metadata\nls /.stargz-snapshotter/\ncat /.stargz-snapshotter/*.json\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-binary-verification",children:"3. Binary Verification"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Check STARGZ footer (authoritative proof)\nsudo tail -c 100 /var/lib/containerd/.../blobs/sha256/... | xxd | tail -3\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-monitor-on-demand-fetches",children:"4. Monitor On-Demand Fetches"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Watch stargz-snapshotter logs\nsudo journalctl -u stargz-snapshotter -f\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"quick-reference-commands",children:"Quick Reference Commands"}),"\n",(0,r.jsx)(n.h3,{id:"setup",children:"Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Start local registry\ndocker run -d --name registry -p 5000:5000 registry:2\n\n# Start stargz-snapshotter\nsudo systemctl start stargz-snapshotter\n"})}),"\n",(0,r.jsx)(n.h3,{id:"benchmarking",children:"Benchmarking"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Build tool\ncd startup-bench && go build -o startup-bench main.go\n\n# Cold start with lazy pulling (auto-detected via :esgz suffix)\nsudo ./startup-bench \\\n  -image=localhost:5000/workload-2048mb-few-large:esgz \\\n  -snapshotter=stargz \\\n  -mode=cold \\\n  -iterations=3\n\n# Cold start with regular pull\nsudo ./startup-bench \\\n  -image=localhost:5000/workload-2048mb-few-large:latest \\\n  -snapshotter=overlayfs \\\n  -mode=cold \\\n  -iterations=3\n"})}),"\n",(0,r.jsx)(n.h3,{id:"cleanup",children:"Cleanup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Clean content store for true cold starts\nsudo ctr-remote content ls | grep workload | awk '{print $1}' | \\\n  xargs -I {} sudo ctr-remote content rm {}\n\n# Restart services\nsudo systemctl restart stargz-snapshotter\nsudo systemctl restart containerd\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"external-resources",children:"External Resources"}),"\n",(0,r.jsx)(n.h3,{id:"official-documentation",children:"Official Documentation"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Stargz-Snapshotter"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/stargz-snapshotter/blob/main/docs/overview.md",children:"Project Overview"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/stargz-snapshotter/blob/main/docs/getting-started.md",children:"Getting Started Guide"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/stargz-snapshotter/blob/main/docs/ctr-remote.md",children:"ctr-remote CLI Tool"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/stargz-snapshotter/blob/main/docs/overview.md#registry-mirrors-and-insecure-connection",children:"Registry Configuration"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/stargz-snapshotter",children:"GitHub Repository"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Containerd"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/containerd/tree/main/docs",children:"Official Documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/containerd/blob/main/docs/garbage-collection.md",children:"Garbage Collection"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/containerd/blob/main/docs/content-flow.md",children:"Content Store Design"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/containerd/blob/main/docs/namespaces.md",children:"Namespaces"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/containerd/blob/main/docs/snapshotters/README.md",children:"Snapshotters"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/containerd",children:"GitHub Repository"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"OCI Specifications"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/opencontainers/image-spec",children:"OCI Image Spec"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/opencontainers/image-spec/blob/main/media-types.md",children:"Media Types"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/opencontainers/image-spec/blob/main/layer.md",children:"Image Layer Spec"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"eStargz Format"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/stargz-snapshotter/blob/main/docs/estargz.md",children:"eStargz Paper"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/stargz-snapshotter/blob/main/docs/stargz-estargz.md",children:"Format Specification"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"related-tools--projects",children:"Related Tools & Projects"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Container Runtimes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://containerd.io/",children:"containerd"})," - Industry-standard container runtime"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/opencontainers/runc",children:"runc"})," - OCI container runtime"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Image Optimization"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/moby/buildkit",children:"Buildkit"})," - Concurrent, cache-efficient build toolkit"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/dragonflyoss/nydus",children:"Nydus"})," - Alternative lazy-pulling solution by Dragonfly"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Registries"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://docs.docker.com/registry/",children:"Docker Registry"})," - Open-source registry implementation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/opencontainers/distribution-spec",children:"Distribution Spec"})," - OCI distribution specification"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"research-papers--articles",children:"Research Papers & Articles"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lazy Pulling & Container Startup"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.usenix.org/conference/fast20/presentation/li",children:"FAST '20: Startup Containers in Lightning Speed with Lazy Image Distribution"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.usenix.org/conference/fast16/technical-sessions/presentation/harter",children:"Slacker: Fast Distribution with Lazy Docker Containers"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Container Image Optimization"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.usenix.org/conference/atc19/presentation/zhao-jian",children:"USENIX ATC '19: Packer: Toward Million-fold Container Image Optimization"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"community--support",children:"Community & Support"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Issue Trackers"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/stargz-snapshotter/issues",children:"Stargz-Snapshotter Issues"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/containerd/issues",children:"Containerd Issues"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/dragonflyoss/nydus/issues/1527",children:"Nydus Lazy Pulling Issue #1527"})," - Related metadata corruption"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Communication"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://slack.containerd.io/",children:"Containerd Slack"})," - Community chat"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://cloud-native.slack.com/messages/containerd",children:"CNCF Slack #containerd"})," - Technical discussions"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"tutorials--guides",children:"Tutorials & Guides"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Getting Started"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://containerd.io/docs/getting-started/",children:"Containerd Getting Started"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/stargz-snapshotter/blob/main/docs/getting-started.md",children:"Stargz-Snapshotter Quick Start"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Advanced Topics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/stargz-snapshotter/blob/main/docs/overview.md#lazy-pulling-feature",children:"Lazy Pulling Deep Dive"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/containerd/stargz-snapshotter/blob/main/docs/ctr-remote.md#building-estargz",children:"Building eStargz Images"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsx)(n.h3,{id:"technical-insights",children:"Technical Insights"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lazy pulling is essential for large images"})," - 150x pull speedup for 2GB images"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Label handlers are critical"})," - Regular containerd.Pull() doesn't enable lazy pulling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Content store is global"})," - Shared across namespaces, requires explicit cleanup"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Never mix pull methods"})," - Causes metadata corruption"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"eStargz verification"})," - Check STARGZ footer in blobs, not just media type"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Speedup scales with image size"})," - Larger images benefit more"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Network-dependent"})," - Requires good bandwidth/latency to registry"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Working set matters"})," - Only fetches accessed files"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trade-off exists"})," - Faster pull, slightly slower start"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zero storage overhead"})," - No disk caching of full layers"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"development-best-practices",children:"Development Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance-driven debugging"})," - Timing anomalies reveal bugs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Binary-level verification"})," - Source of truth for format validation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Read upstream source code"})," - Reveals exact implementation details"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test with realistic workloads"})," - Small images don't show benefits"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Match system versions"})," - Library versions should align with binaries"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsxs)(n.p,{children:["This project demonstrates that ",(0,r.jsx)(n.strong,{children:"eStargz with lazy pulling provides dramatic performance improvements for startup latency"}),", but reveals a ",(0,r.jsx)(n.strong,{children:"critical trade-off with total workload completion time"})," that depends on working set size."]}),"\n",(0,r.jsx)(n.h3,{id:"key-findings-1",children:"Key Findings"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"\u2705 Lazy Pulling Wins for Startup Latency:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"150x faster pull time (9.2s \u2192 0.06s)"}),"\n",(0,r.jsx)(n.li,{children:"13.9x faster cold start (9.4s \u2192 0.67s)"}),"\n",(0,r.jsx)(n.li,{children:"Zero disk storage overhead"}),"\n",(0,r.jsx)(n.li,{children:"Ideal for small working sets (<10% of image)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"\u26a0\ufe0f Eager Loading Wins for Data-Intensive Workloads:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"1.5-2x faster total completion for large working sets (>30% of image)"}),"\n",(0,r.jsx)(n.li,{children:"Bulk parallel downloads faster than serialized on-demand fetches"}),"\n",(0,r.jsx)(n.li,{children:"Better for batch processing, training, ETL pipelines"}),"\n",(0,r.jsx)(n.li,{children:"Stress test (8GB sequential read): Overlayfs 45-54s vs Stargz 79-88s"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"decision-framework",children:"Decision Framework"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"The critical question: What percentage of your image does the workload access?"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Small working set (&lt;10%):\n  \u2192 Lazy pulling essential (13.9x faster)\n  \u2192 Example: LLM inference API loading 300MB of 4GB image\n\nLarge working set (>30%):\n  \u2192 Eager loading faster (1.5-2x faster total time)\n  \u2192 Example: Training job accessing 7GB of 8GB image\n\nOptimize for startup time:\n  \u2192 Always use lazy pulling\n\nOptimize for total completion time:\n  \u2192 Use lazy pulling only for small working sets\n"})}),"\n",(0,r.jsx)(n.h3,{id:"production-recommendations",children:"Production Recommendations"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"LLM Inference/Serving"})," - Use lazy pulling \u2705"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Small working set, startup critical"}),"\n",(0,r.jsx)(n.li,{children:"10-20x faster cold start for auto-scaling"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"LLM Training/Fine-tuning"})," - Use eager loading \u2705"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Large working set, total time matters"}),"\n",(0,r.jsx)(n.li,{children:"Avoid 1.5-2x penalty for on-demand fetches"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Development/Testing"})," - Use lazy pulling \u2705"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fast iteration cycles"}),"\n",(0,r.jsx)(n.li,{children:"Disk space savings"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"technical-validation",children:"Technical Validation"}),"\n",(0,r.jsx)(n.p,{children:"The implementation validates that:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Proper integration with stargz-snapshotter enables true lazy pulling"}),"\n",(0,r.jsxs)(n.li,{children:["Label handlers (",(0,r.jsx)(n.code,{children:"AppendDefaultLabelsHandlerWrapper"}),") are essential"]}),"\n",(0,r.jsx)(n.li,{children:"Content store management critical for accurate benchmarking"}),"\n",(0,r.jsx)(n.li,{children:"Working set size is the primary performance factor"}),"\n",(0,r.jsx)(n.li,{children:"Network vs disk I/O trade-off is significant for large data access"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var i=s(6540);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);